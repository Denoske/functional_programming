# Лабораторная работа №2

- Выполнил: `Голиков Денис Игоревич`
- Группа: `P34102`
- Ису: `282581`
- Язык: `Erlang`

## Separate Chaining Hashmap Set

## Требования

1. Функции:

    - добавление и удаление элементов;
    - фильтрация;
    - отображение (map);
    - свертки (левая и правая);
    - структура должна быть моноидом.

2. Структуры данных должны быть неизменяемыми.
3. Библиотека должна быть протестирована в рамках unit testing.
4. Библиотека должна быть протестирована в рамках property-based тестирования (как минимум 3 свойства, включая свойства моноида).
5. Структура должна быть полиморфной.
6. Требуется использовать идиоматичный для технологии стиль программирования. Примечание: некоторые языки позволяют получить большую часть API через реализацию небольшого интерфейса. Так как лабораторная работа про ФП, а не про экосистему языка -- необходимо реализовать их вручную и по возможности -- обеспечить совместимость.

## Реализация

За основу был взят map (`%{}`). В целом, можно обойтись и без него, реализовав что-то похожее на массиве кортежей ключ-значение.

Для хэширования используется `:erlang.phash2/1`, описание:

> Portable hash function that gives the same hash for the same Erlang term
regardless of machine architecture and ERTS version.

Подходит под задачу, к тому же, ее использует и ныне deprecated HashSet.

Значения же в рамках одной цепочки (когда совпадают хэши) хранятся в массивах.

Для того, чтобы структура была моноидом, создан метод `union/2`, который принимает два set-а и возвращает их объединение. Написан property-тест на удовлетворение требованиям ([здесь](https://github.com/Denoske/functional_programming/blob/main/lab_2/test/lab2_app.erl)).

Помимо функционала, указанного в задании, также реализованы следующие операции:

- `member?/2` - для проверки, что элемент есть в сете
- `size/1` - для получения кол-ва элементов в сете
- `contains_all?/2` - для проверки, что все элементы второго сета - члены первого сета
- `equal?/2` - для сравнения двух сетов (т.к. если проверять "втупую", то можно споткнуться о порядок элементов в цепочках, а его мы должны игнорировать)


## Выводы

Во-первых, ранее не доводилось задумываться, что избежать коллизий в set-е можно с помощью хранения элементов в массивах. Интересная и довольно простая идея.

Во-вторых, впервые столкнулся с property-тестированием. С похожими видами тестирования я в разной степени уже сталкивался (fuzzing с точки зрения генерации входных данных, mock-ирование, с точки зрения делегированием контроля над входными данными фреймворку), но конкретно property-based тестирование для меня ново. Определенно красивый и грамотный подход, однако далеко не везде применимый и _абсолютно точно_ не исчерпывающий.

В-третьих, очень понравилось работать с иммутабельными структурами данных - во время написания кода испытывал фрустрации, однако мне несомненно понравилось и с точки зрения кода без сайд-эффектов, это довольно занимательно.

